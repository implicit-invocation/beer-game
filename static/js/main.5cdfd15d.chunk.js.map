{"version":3,"sources":["index.js"],"names":["a","canvas","document","getElementById","info","overlay","resizeCanvas","width","height","worldWidth","worldHeight","gl","getContext","loadTexture","bg","platformTex","circleCanTex","rectCanTex","world","b2World","b2Vec2","whiteTex","createWhiteTex","batch","createBatch","camera","createOrthoCamera","inputHandler","InputHandler","createRectCan","x","y","w","h","density","bodyDef","b2BodyDef","type","b2BodyType","b2_dynamicBody","position","Set","body","CreateBody","shape","b2PolygonShape","SetAsBox","CreateFixture","createCircleCan","r","verts","i","v","SelfRotate","Math","PI","push","platform","b2_kinematicBody","createUnbalancePlatform","PLATFORM_WIDTH","circleCans","rectCans","PLATFORM_SPEED","PLATFORM_ACCELERATION","platformSpeed","platformAcceleration","gameOver","initGame","can","DestroyBody","length","SetAngle","restartGame","style","display","addEventListener","screenPos","Vector2","worldPos","set","unprojectVector2","e","which","clearColor","tmp","worldPoint","update","delta","clear","COLOR_BUFFER_BIT","GetPosition","max","min","SetAngularVelocity","Step","setProjection","combined","begin","draw","PLATFORM_HEIGHT","GetAngle","circleCan","CIRCLE_CAN_RADIUS","rectCan","RECT_CAN_WIDTH","RECT_CAN_HEIGHT","end","GetBodyList","GetNext","pos","fixture","GetFixtureList","GetShape","GetType","b2ShapeType","e_polygonShape","vertices","m_vertices","vertice","GetWorldPoint","drawPolygon","e_circleShape","drawCircle","m_radius","game","createGameLoop","setInterval","innerHTML","round","getFps","init"],"mappings":"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","file":"static/js/main.5cdfd15d.chunk.js","sourcesContent":["import \"./index.css\";\n\nimport {\n  createGameLoop,\n  resizeCanvas,\n  createBatch,\n  createOrthoCamera,\n  drawCircle,\n  drawPolygon,\n  InputHandler,\n  Vector2,\n  loadTexture\n} from \"gdxjs\";\nimport createWhiteTex from \"gl-white-texture\";\nimport {\n  b2World,\n  b2Vec2,\n  b2BodyDef,\n  b2BodyType,\n  b2PolygonShape,\n  b2ShapeType\n} from \"box2d.ts\";\n\nconst init = async () => {\n  const canvas = document.getElementById(\"main\");\n  const info = document.getElementById(\"info\");\n  const overlay = document.getElementById(\"overlay\");\n  const [width, height] = resizeCanvas(canvas, 1);\n  const [worldWidth, worldHeight] = [(10 / height) * width, 10];\n  const gl = canvas.getContext(\"webgl\");\n\n  const bg = await loadTexture(gl, \"./art/bg.jpg\");\n  const platformTex = await loadTexture(gl, \"./art/disk.png\");\n  const circleCanTex = await loadTexture(gl, \"./art/can-1.png\");\n  const rectCanTex = await loadTexture(gl, \"./art/can-2.png\");\n\n  const world = new b2World(new b2Vec2(0, 10));\n\n  const whiteTex = createWhiteTex(gl);\n  const batch = createBatch(gl);\n  const camera = createOrthoCamera(worldWidth, worldHeight, width, height);\n  const inputHandler = new InputHandler(canvas);\n\n  const createUnbalancePlatform = (world, x, y, w, h) => {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_kinematicBody;\n    bodyDef.position.Set(x, y);\n    const body = world.CreateBody(bodyDef);\n    const shape = new b2PolygonShape();\n    shape.SetAsBox(w / 2, h / 2, new b2Vec2(0, 0), 0);\n    body.CreateFixture(shape, 1);\n    return body;\n  };\n\n  const createRectCan = (world, x, y, w, h, density = 1) => {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_dynamicBody;\n    bodyDef.position.Set(x, y);\n    const body = world.CreateBody(bodyDef);\n    const shape = new b2PolygonShape();\n    shape.SetAsBox(w / 2, h / 2, new b2Vec2(0, 0), 0);\n    body.CreateFixture(shape, density);\n    return body;\n  };\n\n  const createCircleCan = (world, x, y, r) => {\n    const bodyDef = new b2BodyDef();\n    bodyDef.type = b2BodyType.b2_dynamicBody;\n    bodyDef.position.Set(x, y);\n    const body = world.CreateBody(bodyDef);\n    const shape = new b2PolygonShape();\n    const verts = [];\n    for (let i = 0; i < 12; i++) {\n      const v = new b2Vec2(0, r);\n      v.SelfRotate((Math.PI / 6) * i);\n      verts.push(v);\n    }\n    shape.Set(verts, 12);\n    body.CreateFixture(shape, 1);\n    return body;\n  };\n\n  const PLATFORM_WIDTH = (worldWidth * 3) / 4;\n  const PLATFORM_HEIGHT = 0.2;\n  const platform = createUnbalancePlatform(\n    world,\n    worldWidth / 2,\n    (worldHeight * 2) / 3,\n    PLATFORM_WIDTH,\n    PLATFORM_HEIGHT\n  );\n\n  const CIRCLE_CAN_RADIUS = 0.3;\n  const circleCans = [];\n  const rectCans = [];\n  const RECT_CAN_HEIGHT = 1.2;\n  const RECT_CAN_WIDTH = 0.6;\n\n  const PLATFORM_SPEED = Math.PI / 4;\n  const PLATFORM_ACCELERATION = Math.PI;\n  let platformSpeed = 0;\n  let platformAcceleration = PLATFORM_ACCELERATION;\n\n  let gameOver = true;\n\n  const initGame = () => {\n    gameOver = false;\n    platformSpeed = 0;\n    platformAcceleration = PLATFORM_ACCELERATION;\n    for (let can of circleCans) {\n      world.DestroyBody(can);\n    }\n    circleCans.length = 0;\n\n    for (let can of rectCans) {\n      world.DestroyBody(can);\n    }\n    rectCans.length = 0;\n\n    platform.SetAngle(0);\n\n    circleCans.push(\n      createCircleCan(world, worldWidth / 2, worldHeight / 2, CIRCLE_CAN_RADIUS)\n    );\n\n    rectCans.push(\n      createRectCan(\n        world,\n        (worldWidth * 2) / 3 - 0.1,\n        worldHeight / 2,\n        RECT_CAN_WIDTH,\n        RECT_CAN_HEIGHT,\n        3\n      )\n    );\n    rectCans.push(\n      createRectCan(\n        world,\n        worldWidth / 3 + 0.1,\n        worldHeight / 2,\n        RECT_CAN_WIDTH,\n        RECT_CAN_HEIGHT,\n        3\n      )\n    );\n    rectCans.push(\n      createRectCan(\n        world,\n        worldWidth / 2,\n        worldHeight / 3,\n        RECT_CAN_WIDTH,\n        RECT_CAN_HEIGHT,\n        3\n      )\n    );\n    rectCans[2].SetAngle(Math.PI / 2);\n  };\n\n  const restartGame = () => {\n    initGame();\n    overlay.style.display = \"none\";\n  };\n\n  overlay.addEventListener(\"click\", () => {\n    restartGame();\n  });\n\n  initGame();\n\n  // circleCans.push(\n  //   createCircleCan(\n  //     world,\n  //     worldWidth / 2,\n  //     worldHeight / 2 - 2 * CIRCLE_CAN_RADIUS,\n  //     CIRCLE_CAN_RADIUS\n  //   )\n  // );\n\n  // let platformAcceleration = 0;\n\n  const screenPos = new Vector2(0, 0);\n  const worldPos = new Vector2(0, 0);\n  inputHandler.addEventListener(\"touchStart\", (x, y) => {\n    screenPos.set(x, y);\n    camera.unprojectVector2(worldPos, screenPos);\n\n    if (worldPos.x < worldWidth / 2) {\n      platformAcceleration = -PLATFORM_ACCELERATION;\n    } else {\n      platformAcceleration = PLATFORM_ACCELERATION;\n    }\n  });\n\n  // inputHandler.addEventListener(\"touchEnd\", () => (platformAcceleration = 0));\n  document.addEventListener(\"keydown\", e => {\n    if (e.which === 65) {\n      platformAcceleration = -PLATFORM_ACCELERATION;\n    } else if (e.which === 68) {\n      platformAcceleration = PLATFORM_ACCELERATION;\n    } else if (e.which === 82 && gameOver) {\n      restartGame();\n    }\n  });\n  // document.addEventListener(\"keyup\", () => (platformAcceleration = 0));\n\n  gl.clearColor(0, 0, 0, 1);\n  const tmp = [];\n  const worldPoint = new b2Vec2(0, 0);\n  const update = delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    if (!gameOver) {\n      for (let can of circleCans) {\n        if (can.GetPosition().y >= worldHeight) {\n          gameOver = true;\n          break;\n        }\n      }\n      for (let can of rectCans) {\n        if (can.GetPosition().y >= worldHeight) {\n          gameOver = true;\n          break;\n        }\n      }\n      if (gameOver) {\n        overlay.style.display = \"flex\";\n      }\n    }\n\n    if (!gameOver) {\n      platformSpeed += platformAcceleration * delta;\n      platformSpeed = Math.max(platformSpeed, -PLATFORM_SPEED);\n      platformSpeed = Math.min(platformSpeed, PLATFORM_SPEED);\n      platform.SetAngularVelocity(platformSpeed);\n      world.Step(delta, 8, 3);\n    }\n\n    batch.setProjection(camera.combined);\n    batch.begin();\n    batch.draw(bg, 0, 0, worldWidth, worldHeight);\n    batch.draw(\n      platformTex,\n      platform.GetPosition().x - PLATFORM_WIDTH / 2,\n      platform.GetPosition().y - PLATFORM_HEIGHT / 2,\n      PLATFORM_WIDTH,\n      PLATFORM_HEIGHT,\n      PLATFORM_WIDTH / 2,\n      PLATFORM_HEIGHT / 2,\n      platform.GetAngle()\n    );\n\n    for (let circleCan of circleCans) {\n      const position = circleCan.GetPosition();\n      batch.draw(\n        circleCanTex,\n        position.x - CIRCLE_CAN_RADIUS,\n        position.y - CIRCLE_CAN_RADIUS,\n        CIRCLE_CAN_RADIUS * 2,\n        CIRCLE_CAN_RADIUS * 2,\n        CIRCLE_CAN_RADIUS,\n        CIRCLE_CAN_RADIUS,\n        circleCan.GetAngle()\n      );\n    }\n    for (let rectCan of rectCans) {\n      const position = rectCan.GetPosition();\n      batch.draw(\n        rectCanTex,\n        position.x - RECT_CAN_WIDTH / 2,\n        position.y - RECT_CAN_HEIGHT / 2,\n        RECT_CAN_WIDTH,\n        RECT_CAN_HEIGHT,\n        RECT_CAN_WIDTH / 2,\n        RECT_CAN_HEIGHT / 2,\n        rectCan.GetAngle()\n      );\n    }\n    // debugBox2d();\n    batch.end();\n  };\n\n  const debugBox2d = () => {\n    for (let body = world.GetBodyList(); body; body = body.GetNext()) {\n      const pos = body.GetPosition();\n      for (\n        let fixture = body.GetFixtureList();\n        fixture;\n        fixture = fixture.GetNext()\n      ) {\n        const shape = fixture.GetShape();\n        if (shape.GetType() === b2ShapeType.e_polygonShape) {\n          const vertices = shape.m_vertices;\n          tmp.length = 0;\n          for (let vertice of vertices) {\n            body.GetWorldPoint(vertice, worldPoint);\n            tmp.push(worldPoint.x, worldPoint.y);\n          }\n          drawPolygon(batch, whiteTex, tmp, 0.05, 0, 0, 0);\n        } else if (shape.GetType() === b2ShapeType.e_circleShape) {\n          drawCircle(\n            batch,\n            whiteTex,\n            pos.x,\n            pos.y,\n            shape.m_radius,\n            0.05,\n            10,\n            0,\n            0,\n            0\n          );\n        }\n      }\n    }\n  };\n\n  const game = createGameLoop(update);\n  setInterval(\n    () => (info.innerHTML = `FPS: ${Math.round(game.getFps())}`),\n    1000\n  );\n};\n\ninit();\n"],"sourceRoot":""}